类加载时机
生命周期
    加载
    验证/准备/解析:连接阶段
    初始化
    使用
    卸载
    使用和解析并不是按部就班开始
4种情况必须对类初始化(主动引用,其余引用为被动引用)
    1：new/赋值静态变量以及调用静态方法
    2：反射
    3：初始化一个类,父类如还没初始化，先初始化其父类
    4：虚拟机启动时,用户指定要执行的main()
被动引用
    详情看SuperClass
    被动使用1：对于静态字段,只有直接定义这个字段的类才会被初始化,因此通过其子类来引用父类中定义的静态字段,
             只会触发父类的初始化 -XX:TraceClassLoading：此操作会导致子类的加载
    被动使用2:没有触发SuperClass初始化,但是触发了另一个名为[Lorg.包名.SuperClass的类初始化阶段
             有虚拟机自动生成,继承Object的子类,创建动作由newarray触发
             代表SupClass的一维数组,可直接使用length/clone
    被动引用3：对SuperClass.HELOO_WORLD的引用实际都转化为Main类对自身常量池的引用
接口加载过程,如上4条，但是第三条不需要父接口全部初始化,只有真正使用到父接口时(如:引用接口中定义的常量)才会初始化

类加载3过程
    通过类全限定名来获取定义此类的二进制字节流,可以从jar,war,网络(applet),运行时计算生成(reflect),文件jsp等
    将字节流代表的静态存储结构转化方法区的运行时数据结构
    java堆中生成一个代表这个类的java.lang.Class对象,作为方法区数据访问入口
验证4阶段:虚拟机保护机制
    文件格式验证:验证字节流是否符合class文件格式规范
    元数据验证:对字节码描述信息语义分析,一些类的实现以及继承规则
    字节码验证:进行数据流和控制流分析,保证被校验类的方法在运行时不会做出危害虚拟机安全行为,jdk1.6提供了stackMapValue属性,解决字节码的类型推导转变为类型检查,节省时间
    符号引用验证:发生在虚拟机引用转化为直接引用的时候,这个转化将在连接的第三个阶段,解析发生。
准备:
    为类变量分配内存并设置类变量初始值,内存在方法区分配,分配的仅包括类变量，
    public static int a=123
    初始值指的是数据类型的零值,赋值为123在clinit()中
    如果是常量字段,直接赋值为123
解析:
    虚拟机将常量池中符号引用替换为直接引用的过程
    符号引用:一组符号描述引用目标,符号可以是任何形式字面量,只要能定位目标即可,引用目标不一定加载内存中
    直接引用:指向目标指针,相对偏移量或是一个能间接定位目标的句柄。引用目标必定在内存存在
    主要针对4类符号引用进行,对应常量池中CONSTANT_Class_info(类/接口),CONSTANT_Fieldref_info,CONSTANT_Methodref_info,CONSTANT_InterfaceMethodref_info
初始化:
    执行类构造器clinit()方法的过程,
类加载器,看ClassLoaderTest类
    用于实现类的加载动作,对于任意一个类,都需要由加载它的类加载器和这个类本身一同确认其在java虚拟机中的唯一性
    2个类来源同一Class文件,加载器不同,那么这2类不同
3类类加载器
    启动类加载器:lib/rt.jar或者-Xbootclasspath参数指定的路径
    扩展类加载器:lib/ext或者java。ext.dirs系统变量指定的路径中的所有类库,开发者可直接扩展
    应用程序类加载器:家在用户类路径上指定的类库,默认
双亲委派模式
    应用程序由这3种类加载器互相配合进行加载,
    类加载器获得加载请求,委托给父类加载器去完成，父类加载器不能完成则子加载器去尝试加载
    实现在classLoad/loadClass()中
