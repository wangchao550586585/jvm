1:程序计数器
当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复..都依赖这个计数器完成
如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码字节码指令的地址
如果正在执行的是native方法，这个计数器值为空
此内存区域是唯一一个在java虚拟机规范中没有规定任何outOfMemoryError情况的区域

2:java虚拟机栈，为虚拟机执行java方法(字节码)服务
线程私有，生命周期与线程相同，
虚拟机栈描述的是java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表，
操作栈，动态链接，方法出口等信息，每一个方法被调用直至执行完成的过程，
就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

局部变量表存放了编译器可知的各种基本数据类型，boolean，byte，char,long(2个局部变量空间),double(2个局部变量空间)。。。
对象引用(reference类型)他不等于对象本身。根据不同的虚拟机实现，
他可能是一个指向对象起始地址的引用指针，
可能指向一个代表对象的句柄或者其他与此对象相关的位置和returnAddress类型(指向一条字节码指令的地址)

局部变量所需的内存空间在编译期间完成分配，当进入一个方法时，
这个方法需要在帧中分配多大的局部变量空间完全确定的。
在方法运行期间不会改变局部变量表的大小

此区域规定2种异常状态
线程请求栈深入大于虚拟机所允许的深度:StackOverflowError
如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出outofMemoryError异常

3:本地方法栈，为虚拟机使用到的native方法服务
同上类似

4：java堆
是java虚拟机所管理的内存中最大的一块，
所有线程共享的一块区域
虚拟机启动时创建
作用：存放对象实例，几乎所有对象实例都在这里分配内存
是垃圾收集器管理的主要区域，
如果在堆中没有内存完成实例分配，并且堆也无法在扩展，抛出outofmemoryError

5：方法区(HotSpot虚拟机中的永久代)
是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据
这个区域内存回收目标只要是针对常量池的回收和对类型的卸载。
无法满足内存分配时：outofmemoryError

6:运行时常量池
方法区一部分，用于存放编译器生成的各种字面量和符号引用，翻译出来的直接引用
具备动态性，java语言并不要求常量一定只能在编译器产生，也就是并非预植入class文件中常量池的内容
才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，如String.intern()；
无法申请内存：outofMemoryError

7:直接内存
不是虚拟机运行时数据区的一部分，也不是java虚拟机规范定义的内存区域
使用native函数库直接分配堆外内存，然后通过一个存储在java堆厘米那的directByteBuffer对象作为这块区域的引用进行操作，
避免在java堆和native堆中来回复制数据，提高性能

8:对象访问
Object obj=new Object();
Object obj引用存储在栈中，
new Object()存储在堆中
使用句柄访问
java堆中会划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的地址信息
优点：在对象被移动时只会改变句柄中的实例数据指针，而reference不需要修改

直接访问
reference中直接存储对象地址，对象地址里面指定对象数据类型
优点：速度快，节省一次指针定位的时间开销。





