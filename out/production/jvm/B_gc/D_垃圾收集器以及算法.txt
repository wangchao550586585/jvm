垃圾收集算法
标记-清除算法
	算法分为标记和清除2个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象
	缺点：效率不高，标记和清除过程的效率都不高，
		空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，
					当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而
					不得不提前触发另一次垃圾收集动作

复制算法
	将可用内存按容量划分为大小相等的2块，每块只使用其中的一块，当这一块的内存用完了，
	就将还存活着的对象复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。
	这样使得每次都是对其中一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，
	优点，只需要移动堆订指针，按顺序分配内存即可，实现简单，运行高效，
	代价：内存缩小到原来的一半。
	
	优化版：将内存分为一块较大的Eden空间和2块较小的Survivor空间，每次使用Eden和其中一块Survivor。
			当回收时，将Eden和Survivor中还存活这的对象一次性地拷贝到另外一个Survivor中，最后清理
			Eden和刚才用过的Survivor。HotSpot虚拟机默认Eden和Survivor比例为8：1。
			当Survivor不够用时，需要依赖其他内存(老年代)进行分配担保
	
	缺点：在对象存活率较高时，需要执行较多的复制操作，效率会很低。其次，如果不想浪费50%空间就需要
			额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，在老年代一般不能直接使用此算法
			
标记-整理算法
	与标记-清除算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

分代收集算法
		根据对象的存活周期的不同将内存划分为几块，
		java堆分成新生代和老年代，根据各个年代的特点采用最适当的收集算法
		在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集
		老年代中因为对象存活率高没有额外空间对他进行分配担保，就必须使用标记-清理或标记-整理算法进行回收

垃圾收集器	
Serial收集器：单线程的收集器，进行垃圾收集时，必须暂停其他所有的工作线程。直到他收集结束。
			优点：简单高效，没有线程交互的开销，
			新生代采用复制算法暂停所有线程，老年代采取标记-整理算法暂停所有用户线程
ParNew收集器：Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余Serial收集器可用的所有控制参数，收集算法,对象分配都一样
			多个新生代采取复制算法暂停所有用户线程，老年代同上。
			使用-XX:+UseConcMarkSweepGC设置默认新生代收集器
			-XX+UseParNewGC强制指定它
			-XX:ParallelGCThreads限制垃圾收集的线程数
Parallel Scavenge收集器(吞吐量优先收集器)：新生代收集器，使用复制算法，并行的多线程收集器
			作用：达到一个可控制的吞吐量，吞吐量值得是CPU用于运行用户代码的时间与CPU总消耗时间的比值
					即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，
					虚拟机总运行了100分钟，垃圾收集花费1分钟，吞吐量就是99%		
			停顿时间越短就越适合需要与用户交互的程序，提交用户体验
			高吞吐量则可以最高效率的利用cpu时间，尽快完成程序的运行任务，适合在后台运算而不需要太多交互的任务
			-XX：MaxGCPauseMillis:控制最大垃圾收集停顿时间
									允许值大于0的毫秒数，收集器将尽力保证内存回收花费不超过此设定时间值
			-XX:GCTimeRatio：设置吞吐量大小
							0~100之前，垃圾收集时间占总时间的比率，相当于吞吐量的倒数，
								设置为19，则允许最大GC时间就占总时间的1/(1+19),
								默认值为99，就是允许最大的1%,1/(1+99)
			-XX:+UseAdaptiveSizePolicy：开关参数
							开启后不需要手动指定新生代的大小(-Xmn),Eden与Survivor区的比例(-XX:SurvivorRatio)
							晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数，虚拟机会动态调整参数，以提供最合适的停顿时间或最大吞吐量
							这种调节方式称为GC自适应的调节策略，
							只需要设置基本数据即可，如最大堆(0Xmx)，最大停顿时间(MaxGCPauseMillis)，吞吐量(GCTimeRatio)
Serial Old收集器：Serial收集器的老年代版本，单线程，使用标记-整理算法
Parallel Old收集器:是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法，
					适用注重CPU资源，和吞吐连的场合
CMS收集器：以获得最短回收停顿时间为目标的收集器，标记-清除算法
			运行过程
				1：初始标记(暂停其他进程)：标记GC Roots能直接关联到的对象，速度快
				2：并发标记:进行GC Roots Tracing的过程，
				3：重新标记(暂停其他进程):修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
				4：并发清除
			缺点：1：cpu资源敏感
					2：无法处理浮动垃圾，-XX:CMSInitiatingOccupancyFraction配置老年化触发百分比
					3：产生大量碎片,-XX:UseCmScompactAtFullCollection：碎片整理
						-XX:CMSFullGCsBeforeCompaction:设置执行多少次不压缩的FullGC后，压缩
G1收集器：标记-整理,精确控制停顿(小号在垃圾上级上的时间不超过N毫秒)，
			不牺牲吞吐量的前提下完成低停顿的内存回收，因为它能够极力避免全区域的垃圾收集。
			原理：G1将整个JAVA堆(包括新生代，老年代)划分为多个大小固定的独立区域(Region)，
					并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间
					优先回收垃圾最多的区域，保证G1收集器在有限时间内获得最高的收集效率

					
